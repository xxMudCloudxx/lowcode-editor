

### 零、项目状态与进度总览

* **当前状态**: **第一阶段：核心体验与高频功能完善**
* **核心里程碑**: `基础编辑器可用` -> `✅动态应用构建` -> `专业体验` -> `生态闭环`
* **最后更新**: `2025-06-21`

---

### 功能完成度清单 (Checklist)

#### 第一阶段：核心体验与高频功能完善
-   [x] 1.1 实现撤销/重做 (Undo/Redo)
-   [x] 1.2 实现组件的复制 / 粘贴 / 删除
-   [ ] 1.3 大纲树支持拖拽调整层级和顺序

#### 第二阶段：打通数据与逻辑的任督二脉
-   [ ] 2.1 引入全局状态与数据源
-   [ ] 2.2 实现强大的数据绑定

#### 第三阶段：高级功能与生态建设
-   [ ] 3.1 编辑器专业功能增强
-   [ ] 3.2 引入高级布局与业务组件

#### 第四阶段：工程化与产物
-   [ ] 4.1 页面Schema的导入/导出
-   [ ] 4.2 出码与独立发布

---

### 一、文档说明

本文档旨在为本低代码编辑器项目提供一个清晰、分阶段的功能迭代路线图...
(...后续内容保持不变...)

------

### 项目开发规划 (Project Development Plan)

#### 一、文档说明

本文档旨在为本低代码编辑器项目提供一个清晰、分阶段的功能迭代路线图。规划参考了业界优秀的低代码平台（如 Amis, LowCodeEngine），并结合项目当前的技术架构（React, TypeScript, Zustand, React-DND），旨在将项目从现有基础原型，逐步完善为一个功能强大、体验优秀、具备扩展性的低代码解决方案。

**优先级定义:**

- **P0 - 最高 (Highest):** 核心功能缺失，严重影响可用性，必须最优先解决。
- **P1 - 高 (High):** 重要功能，能极大提升产品核心价值和用户效率。
- **P2 - 中 (Medium):** 体验优化或高级功能，能形成产品亮点。
- **P3 - 低 (Low):** 锦上添花或长期工程目标。

------

#### 二、开发路线图 (Roadmap)

##### **第一阶段：核心体验与高频功能完善 (优先级: P0-P1)**

本阶段专注于补齐作为一款“编辑器”最基础的核心能力，扫清基础操作障碍，提升用户操作的流畅度和安全感。

**1.1 实现撤销/重做 (Undo/Redo)**

- **优先级**: P0
- **痛点**: 任何误操作都不可逆，用户没有安全感。
- **技术方案**: 采用 `zustand/middleware/temporal` 中间件，它能非侵入式地为状态增加“时间旅行”能力。
- **核心实现**:    
  - 引入 `temporal` 中间件包裹核心 store。
  -  在 `Header` 组件中添加“撤销”、“重做”按钮，并绑定 `undo()` 和 `redo()` 方法。
  - 关键优化**: **
    - **使用 `partialize` 配置项，仅让 `temporal` 追踪对 `components` 树的修改，避免了选中组件等纯 UI 操作污染历史栈。**
    - **健壮性修复**: 通过 `pause()` 和 `resume()` API 精确控制历史记录，解决了 `partialize` 在某些场景下的失效问题，保证了功能的稳定性。


**1.2 实现组件的复制 / 粘贴 / 删除**

- **优先级**: P0

- **痛点**: 无法快速复用已配置好的组件，只能重复拖拽和设置，效率极低。

- 实施步骤:

  1. **数据层**: 在 `useComponetsStore` 中增加一个新的 state: `clipboard: Component | null`。
  2. **复制逻辑**: 在 `src/editor/components/EditArea/SelectedMask/index.tsx` 的操作栏中添加“复制”功能。点击后，触发 store action，**深拷贝**当前选中的组件对象（**关键**: 必须递归为被拷贝的组件及其所有后代生成全新的`id`），然后存入 `clipboard`。
  3. **粘贴逻辑**: 在 `SelectedMask` 或画布右键菜单中提供“粘贴”功能。触发 store action，读取 `clipboard` 数据，再次执行 ID 刷新（防止连续粘贴时 ID 冲突），然后调用 `addComponent` 方法将其添加到当前选中的容器中。
  4. **快捷键**: 在顶层组件使用 `useEffect` 监听全局 `keydown` 事件，绑定 `Cmd/Ctrl+C`, `Cmd/Ctrl+V`, `Delete` 等快捷键。

**1.3 大纲树支持拖拽调整层级和顺序**

- **优先级**: P1

- **痛点**: 只能通过拖拽画布来调整组件结构，对于深层嵌套的组件非常不便。

- **技术方案**: 使用 `@dnd-kit/sortable` 库改造现有大纲树。

- 实施步骤:

  1. **安装依赖**: `npm install @dnd-kit/core @dnd-kit/sortable`
  2. **重构大纲树**: 重写 `src/editor/components/MaterialWrapper/Outline/index.tsx`，用 `@dnd-kit` 的 `DndContext` 包裹整个树，并将树的每一项都改造成可拖拽和可放置的单元。
  3. **更新状态**: 在拖拽结束的回调 (`onDragEnd`) 中，根据事件信息计算出组件在 `components` 数组中的新位置。建议在 `useComponetsStore` 中新增一个 `moveComponent(draggedId, targetId, position)` 的 action 来封装复杂的数组操作逻辑。

------

##### **第二阶段：打通数据与逻辑的任督二脉 (优先级: P1)**

本阶段是质变的关键，让平台从“静态 UI 搭建”升级为“动态应用构建”。

**2.1 引入全局状态与数据源**

- **优先级**: P1

- **痛点**: 数据是孤岛，无法在组件间共享；应用缺乏从后端获取数据的能力。

- 实施步骤:

  1. **创建新 Store**: 新建 `src/editor/stores/globalState.ts` 用于管理全局变量（如 `userInfo`），以及 `src/editor/stores/dataSources.ts` 用于管理 API 配置列表。
  2. **创建新面板**: 在左侧面板区增加“全局状态”和“数据源”两个 Tab，并开发对应的UI界面，让用户可以增删改查全局变量和 API 配置。
  3. **增加生命周期事件**: 在 `component-config.tsx` 的 `ComponentConfig` 接口中，增加 `lifecycles?: ComponentEvent[]` 属性（如`[{ name: 'onMount', label: '组件加载时' }]`）。这样，在“事件”设置面板中，就会出现这个可配置的事件。
  4. **执行生命周期**: 在 `Preview` 渲染引擎中，使用 `useEffect` 来触发 `onMount` 事件。该事件最典型的应用就是：**调用一个已配置的数据源 -> 获取数据 -> 将结果存入一个全局状态变量**。

**2.2 实现强大的数据绑定**

- **优先级**: P1

- **痛点**: 所有组件属性都是静态值，UI 无法响应数据变化。

- 实施步骤:

  1. **定义表达式语法**: 确定一种简单的数据绑定语法，例如 `{{ globalState.userInfo.name }}`。
  2. **改造设置器**: 在“属性”面板的每个输入框旁，增加一个“绑定数据”按钮，点击后允许用户选择变量或输入表达式。
  3. **创建表达式解析器**: 编写一个工具函数 `evaluate(expression: string, context: object)`，`context` 对象包含所有可访问的数据（如 `globalState`）。
  4. **改造渲染引擎**: 在 `Preview` 的 `renderComponents` 中，传递 `props` 给组件前，先遍历一遍 `props`，如果发现值是 `{{...}}` 格式，就调用 `evaluate` 函数计算出真实值再传递。
  5. **实现条件/列表渲染**: 为组件增加通用的 `hiddenOn` 和 `loopOn` 属性，其值可以是数据绑定表达式。渲染时，通过 `evaluate` 解析这两个属性，若 `hiddenOn` 为真则不渲染该组件；若 `loopOn` 是一个数组，则循环渲染该组件。

------

##### **第三阶段：高级功能与生态建设 (优先级: P2)**

本阶段提升平台能力上限，增强灵活性和可扩展性。

**3.1 编辑器专业功能增强**

- **优先级**: P2

- **痛点**: 缺乏专业编辑器应有的辅助功能，布局效率低。

- 实施步骤:

  - **拖拽辅助线与吸附**: 在拖拽时，实时计算与其它组件的边界距离，当小于阈值时显示对齐线并自动吸附。
  - **画布缩放与标尺**: 通过 CSS `transform: scale()` 控制画布缩放，并引入 `react-ruler` 等库实现标尺。

**3.2 引入高级布局与业务组件**

- **优先级**: P2

- **痛点**: 仅靠自由布局和基础组件，难以搭建复杂的企业级页面。

- 实施步骤:

  - **栅格布局 (Grid)**: 开发一个 `Grid` 容器物料，其 `dev` 版本需要特殊处理拖拽逻辑，允许组件被拖入指定的栅格单元。
  - **Tabs组件**: 开发一个 `Tabs` 容器物料，允许用户在不同的标签页下面板中放置内容。
  - **图表物料**: 集成 `ECharts` 等图表库，将其数据源 `option` 与我们第二阶段实现的“数据源”和“数据绑定”功能打通。

------

##### **第四阶段：工程化与产物 (优先级: P3)**

本阶段关注开发者体验和最终交付价值。

**4.1 页面Schema的导入/导出**

- **优先级**: P3
- **痛点**: 搭建的页面无法保存、分享和复用。
- **实施步骤**: 在 `Header` 中增加“导入/导出”按钮。导出即将 `components` 状态 `JSON.stringify` 后下载；导入即读取JSON文件后，调用 action 重置整个 `useComponetsStore` 的状态。

**4.2 出码与独立发布**

- **优先级**: P3

- **痛点**: 产物与编辑器本身强耦合，无法独立部署。

- 实施步骤:

  - **出码**: 开发一个独立的脚本，可以将 `JSON Schema` 转换为高质量、可阅读的 `React/TSX` 源码。
  - **独立发布**: 构建一个极简的“渲染引擎”运行时（Runtime），这个运行时只包含所有物料的 `prod` 版本和渲染逻辑。发布过程就是将这个 Runtime 和页面的 `JSON Schema` 打包成一个可独立部署的静态应用。