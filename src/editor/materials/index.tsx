/**
 * @file /src/editor/materials/index.tsx
 * @description
 * 物料系统的“自动化注册中心”。
 * 本文件利用 Vite 的 `import.meta.glob` 功能，动态地、自动化地扫描 `/materials` 目录下
 * 所有符合规范的物料组件（即包含 `meta.tsx`, `dev.tsx`, `prod.tsx` 的文件夹），
 * 并将它们整合成一个 `materials` 配置数组，供整个应用使用。
 * 这种设计极大地简化了新增物料的流程，开发者只需创建物料文件，无需修改任何注册代码。
 *
 * 同时，本文件也会**合并脚本自动生成**的 antd 组件元数据（位于 `/_generated` 目录），
 * 并为其自动匹配对应的 `dev.tsx`/`prod.tsx` 外壳组件（如存在）。
 * 当出现重名组件时，优先沿用手写 meta 的定制化设置，并用自动生成的 meta 进行“缺省补齐”。
 * @module Materials/Index
 */
import { lazy, type ComponentType } from "react";
import type {
  ComponentConfig,
  ComponentEvent,
  ComponentSetter,
} from "../stores/component-config";

/**
 * @description 动态、同步地导入所有“手写物料”的 `meta.tsx` 文件。
 * - 避免与自动生成目录 `/_generated` 重复扫描。
 * - `eager: true`: 构建时直接打包进来，模块加载即得。
 * - `import: "default"`: 仅取默认导出。
 */
const manualMetasAll = import.meta.glob("./**/meta.tsx", {
  eager: true,
  import: "default",
});
// 过滤掉 _generated 目录（如果你的 Vite 版本支持 ignore 选项，也可以直接用 ignore）
const manualMetas = Object.fromEntries(
  Object.entries(manualMetasAll).filter(([k]) => !k.startsWith("./_generated/"))
);

/**
 * @description `import.meta.glob` 的问题和解决方案:
 * 1. 问题: 默认情况下，不带 `eager:true` 的 `glob` 返回一个类型为 `Record<string, () => Promise<unknown>>` 的对象。
 * 这里的 `unknown` 类型太宽泛，无法直接传递给 `React.lazy`。
 * 2. `React.lazy` 的要求: `React.lazy` 需要一个返回 `Promise<{ default: React.ComponentType<any> }>` 的函数。
 * 3. 解决方案: 我们为 `import.meta.glob` 传入一个泛型 `<LazyComponentModule>`，明确地告诉 TypeScript
 * 每个动态导入的模块都符合 `React.lazy` 的要求，从而解决了类型不匹配的问题。
 */
type LazyComponentModule = { default: ComponentType<any> };

/**
 * @description 动态地、懒加载地导入所有物料的 `dev.tsx` 与 `prod.tsx` 组件。
 * 这些组件将通过 `React.lazy` 包裹，以实现按需加载和代码分割。
 */
const devComponents = import.meta.glob<LazyComponentModule>("./**/dev.tsx");
const prodComponents = import.meta.glob<LazyComponentModule>("./**/prod.tsx");

/**
 * @description 同步引入脚本生成的 antd 组件 meta（位于 `/_generated` 目录）。
 * 这些 meta 文件仅包含配置（Omit<ComponentConfig, "dev" | "prod">），不直接包含渲染组件。
 * 我们会在后续尝试为其自动匹配同名目录下的 `dev.tsx` 与 `prod.tsx`。
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore - 由生成脚本保证存在
import * as autoGeneratedMetasNS from "./_generated";

/**
 * @description 将“手写物料”的 meta 映射为完整的 `ComponentConfig`。
 * 通过 `meta.tsx` 的路径反推出 `dev.tsx` 和 `prod.tsx` 的动态导入函数。
 */
const manualList: ComponentConfig[] = Object.keys(manualMetas).map((key) => {
  const meta = manualMetas[key] as Omit<ComponentConfig, "dev" | "prod">;
  const base = key.replace("/meta.tsx", "");
  return {
    ...meta,
    dev: lazy(devComponents[`${base}/dev.tsx`]),
    prod: lazy(prodComponents[`${base}/prod.tsx`]),
  };
});

/**
 * @description 将“自动生成”的 meta（仅配置）尝试补全为完整的 `ComponentConfig`。
 * 规则：
 * - 以 `meta.name` 推断出 `./${name}/dev.tsx` 与 `./${name}/prod.tsx` 的相对路径；
 * - 若两者都存在，则纳入物料库；
 * - 若任一不存在，则跳过（并在控制台给出提示）。
 * 注意：此函数**不依赖外部变量**，避免出现 TDZ（Temporal Dead Zone）问题。
 */
function buildGeneratedList(): ComponentConfig[] {
  const result: ComponentConfig[] = [];
  const autoMetas = autoGeneratedMetasNS as Record<
    string,
    Omit<ComponentConfig, "dev" | "prod">
  >;

  Object.values(autoMetas).forEach((meta) => {
    const devKey = `./${meta.name}/dev.tsx`;
    const prodKey = `./${meta.name}/prod.tsx`;
    const devImporter = devComponents[devKey];
    const prodImporter = prodComponents[prodKey];

    if (!devImporter || !prodImporter) {
      // eslint-disable-next-line no-console
      console.warn(
        `[materials] 跳过自动生成的组件 "${meta.name}"：未找到匹配的${
          !devImporter ? ` ${devKey}` : ""
        }${!devImporter && !prodImporter ? " 和" : ""}${
          !prodImporter ? ` ${prodKey}` : ""
        }`
      );
      return;
    }

    result.push({
      ...meta,
      dev: lazy(devImporter),
      prod: lazy(prodImporter),
    });
  });

  return result;
}

const generatedList = buildGeneratedList();

/**
 * @description 工具：合并事件，按 name 去重（手写优先，生成的补缺）
 */
function mergeEvents(manual?: ComponentEvent[], generated?: ComponentEvent[]) {
  const out: ComponentEvent[] = [...(manual ?? [])];
  for (const e of generated ?? []) {
    if (!out.some((x) => x.name === e.name)) out.push(e);
  }
  return out;
}

/**
 * @description 最终合并策略：
 * - 以“手写”项为基底（保留 dev/prod 与你的定制）；
 * - 用“自动生成”补齐缺省字段：
 *   - setter：若手写为空或未提供，则回填为生成的 setter
 *   - events：合并去重
 *   - defaultProps：浅合并（生成在前、手写在后 → 手写覆盖）
 *   - styleSetter/parentTypes：手写优先，缺则用生成的
 * - 同时保留“仅自动生成而没有手写外壳”的组件（这些已在 buildGeneratedList 中确保有 dev/prod）
 */
const genMap = new Map(generatedList.map((g) => [g.name, g]));

const mergedManualFirst: ComponentConfig[] = manualList.map((man) => {
  const gen = genMap.get(man.name);

  const finalSetter: ComponentSetter[] = (
    man.setter && man.setter.length > 0 ? man.setter : gen?.setter ?? []
  ) as ComponentSetter[];

  const finalEvents = mergeEvents(man.events, gen?.events);

  const finalDefaultProps = {
    ...(gen?.defaultProps ?? {}),
    ...(man.defaultProps ?? {}),
  };

  const finalItem: ComponentConfig = {
    ...man,
    desc: man.desc ?? gen?.desc ?? man.name,
    defaultProps: finalDefaultProps,
    setter: finalSetter,
    styleSetter: man.styleSetter ?? gen?.styleSetter ?? [],
    events: finalEvents,
    parentTypes: man.parentTypes ?? gen?.parentTypes,
    // dev/prod：保持手写的外壳（手写优先）
  };

  // 已消费该生成项，从 Map 中删除，剩余的是“只有生成、没有手写”的
  if (gen) genMap.delete(man.name);

  return finalItem;
});

// 剩余仅生成的项也加入（这些在 buildGeneratedList 中已具备 dev/prod）
const onlyGenerated = Array.from(genMap.values());

/**
 * @description 最终导出的、包含了所有物料完整配置的数组。
 * 这是整个低代码编辑器的“物料库”。
 */
export const materials: ComponentConfig[] = [
  ...mergedManualFirst,
  ...onlyGenerated,
];

// （可选）启动期简单观察当前加载到的物料与其 setter 数量。
// console.log(
//   "[materials]",
//   materials.map((m) => ({ name: m.name, setterCount: m.setter?.length ?? 0 }))
// );
