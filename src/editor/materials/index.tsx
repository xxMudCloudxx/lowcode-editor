/**
 * @file /src/editor/materials/index.tsx
 * @description
 * 物料系统的"自动化注册中心"。
 *
 * v2 架构变更：
 * - 支持新协议格式（ComponentProtocol）和旧格式（dev/prod）
 * - 新协议格式的组件只需 meta.tsx + index.tsx
 * - 旧格式组件仍需 meta.tsx + dev.tsx + prod.tsx
 *
 * 本文件利用 Vite 的 `import.meta.glob` 功能，动态地、自动化地扫描 `/materials` 目录下
 * 所有符合规范的物料组件，并将它们整合成一个 `materials` 配置数组。
 *
 * @module Materials/Index
 */
import { lazy, type ComponentType } from "react";
import {
  isProtocolConfig,
  type ComponentConfig,
  type ComponentProtocol,
  type LegacyComponentConfig,
  type EventConfig,
  type SetterConfig,
} from "../types/component-protocol";

/**
 * @description 动态、同步地导入所有"手写物料"的 `meta.tsx` 文件。
 * - 避免与自动生成目录 `/_generated` 重复扫描。
 * - `eager: true`: 构建时直接打包进来，模块加载即得。
 * - `import: "default"`: 仅取默认导出。
 */
const manualMetasAll = import.meta.glob<ComponentConfig>("./**/meta.tsx", {
  eager: true,
  import: "default",
});
// 过滤掉 _generated 目录
const manualMetas = Object.fromEntries(
  Object.entries(manualMetasAll).filter(([k]) => !k.startsWith("./_generated/"))
);

/**
 * @description `import.meta.glob` 的问题和解决方案:
 * 1. 问题: 默认情况下，不带 `eager:true` 的 `glob` 返回一个类型为 `Record<string, () => Promise<unknown>>` 的对象。
 * 2. `React.lazy` 的要求: `React.lazy` 需要一个返回 `Promise<{ default: React.ComponentType<any> }>` 的函数。
 * 3. 解决方案: 我们为 `import.meta.glob` 传入一个泛型，明确地告诉 TypeScript 每个动态导入的模块都符合要求。
 */
type LazyComponentModule = { default: ComponentType<unknown> };

/**
 * @description 动态地、懒加载地导入所有物料的 `dev.tsx` 与 `prod.tsx` 组件（旧格式）。
 */
const devComponents = import.meta.glob<LazyComponentModule>("./**/dev.tsx");
const prodComponents = import.meta.glob<LazyComponentModule>("./**/prod.tsx");

/**
 * @description 同步引入脚本生成的 antd 组件 meta（位于 `/_generated` 目录）。
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore - 由生成脚本保证存在
import * as autoGeneratedMetasNS from "./_generated";

/**
 * @description 将"手写物料"的 meta 映射为完整的 `ComponentConfig`。
 *
 * v2 变更：
 * - 新协议格式（有 component 和 editor 字段）：直接使用
 * - 旧格式：查找 dev.tsx 和 prod.tsx
 */
const manualList: ComponentConfig[] = Object.keys(manualMetas).map((key) => {
  const meta = manualMetas[key];

  // 新协议格式：直接使用（已包含 component）
  if (isProtocolConfig(meta)) {
    return meta;
  }

  // 旧格式：需要查找 dev.tsx 和 prod.tsx
  const legacyMeta = meta as Omit<LegacyComponentConfig, "dev" | "prod">;
  const base = key.replace("/meta.tsx", "");
  const devKey = `${base}/dev.tsx`;
  const prodKey = `${base}/prod.tsx`;

  const devImporter = devComponents[devKey];
  const prodImporter = prodComponents[prodKey];

  if (!devImporter || !prodImporter) {
    console.warn(
      `[materials] 组件 "${legacyMeta.name}" 使用旧格式但缺少 ${!devImporter ? "dev.tsx" : ""} ${!prodImporter ? "prod.tsx" : ""}`
    );
  }

  return {
    ...legacyMeta,
    dev: devImporter ? lazy(devImporter) : undefined,
    prod: prodImporter ? lazy(prodImporter) : undefined,
  } as LegacyComponentConfig;
});

/**
 * @description 将"自动生成"的 meta 尝试补全为完整的 `ComponentConfig`。
 * 规则：
 * - 以 `meta.name` 推断出 dev.tsx 与 prod.tsx 的相对路径
 * - 若两者都存在，则纳入物料库
 * - 若任一不存在，则跳过
 */
function buildGeneratedList(): LegacyComponentConfig[] {
  const result: LegacyComponentConfig[] = [];
  const autoMetas = autoGeneratedMetasNS as Record<
    string,
    Omit<LegacyComponentConfig, "dev" | "prod">
  >;

  Object.values(autoMetas).forEach((meta) => {
    const devKey = Object.keys(devComponents).find((key) =>
      key.endsWith(`/${meta.name}/dev.tsx`)
    );
    const prodKey = Object.keys(prodComponents).find((key) =>
      key.endsWith(`/${meta.name}/prod.tsx`)
    );

    const devImporter = devKey ? devComponents[devKey] : undefined;
    const prodImporter = prodKey ? prodComponents[prodKey] : undefined;

    if (!devImporter || !prodImporter) {
      console.warn(
        `[materials] 跳过自动生成的组件 "${meta.name}"：未找到匹配的${
          !devImporter ? ` dev.tsx` : ""
        }${!devImporter && !prodImporter ? " 和" : ""}${
          !prodImporter ? ` prod.tsx` : ""
        }`
      );
      return;
    }

    result.push({
      ...meta,
      dev: lazy(devImporter),
      prod: lazy(prodImporter),
    });
  });

  return result;
}

const generatedList = buildGeneratedList();

/**
 * @description 工具：合并事件，按 name 去重（手写优先，生成的补缺）
 */
function mergeEvents(manual?: EventConfig[], generated?: EventConfig[]) {
  const out: EventConfig[] = [...(manual ?? [])];
  for (const e of generated ?? []) {
    if (!out.some((x) => x.name === e.name)) out.push(e);
  }
  return out;
}

/**
 * @description 获取组件的 parentTypes
 * 新协议格式从 editor.parentTypes 获取，旧格式从顶层 parentTypes 获取
 */
function getParentTypes(config: ComponentConfig): string[] | undefined {
  if (isProtocolConfig(config)) {
    return config.editor.parentTypes;
  }
  return config.parentTypes;
}

/**
 * @description 最终合并策略：
 * - 以"手写"项为基底
 * - 用"自动生成"补齐缺省字段
 * - 同时保留"仅自动生成"的组件
 */
const genMap = new Map(generatedList.map((g) => [g.name, g]));

const mergedManualFirst: ComponentConfig[] = manualList.map((man) => {
  const gen = genMap.get(man.name);

  // 新协议格式：不需要与 generated 合并（已经是完整的）
  if (isProtocolConfig(man)) {
    if (gen) genMap.delete(man.name);
    return man;
  }

  // 旧格式：需要与 generated 合并
  const legacyMan = man as LegacyComponentConfig;
  const finalSetter: SetterConfig[] = (
    legacyMan.setter && legacyMan.setter.length > 0
      ? legacyMan.setter
      : (gen?.setter ?? [])
  ) as SetterConfig[];

  const finalEvents = mergeEvents(legacyMan.events, gen?.events);

  const finalDefaultProps = {
    ...(gen?.defaultProps ?? {}),
    ...(legacyMan.defaultProps ?? {}),
  };

  const finalItem: LegacyComponentConfig = {
    ...legacyMan,
    desc: legacyMan.desc ?? gen?.desc ?? legacyMan.name,
    defaultProps: finalDefaultProps,
    setter: finalSetter,
    styleSetter: legacyMan.styleSetter ?? gen?.styleSetter ?? [],
    events: finalEvents,
    parentTypes: legacyMan.parentTypes ?? gen?.parentTypes,
  };

  if (gen) genMap.delete(man.name);

  return finalItem;
});

// 剩余仅生成的项也加入
const onlyGenerated = Array.from(genMap.values());

/**
 * @description 最终导出的、包含了所有物料完整配置的数组。
 * 这是整个低代码编辑器的"物料库"。
 */
export const materials: ComponentConfig[] = [
  ...mergedManualFirst,
  ...onlyGenerated,
];

// 导出类型和工具函数，供其他模块使用
export { isProtocolConfig, getParentTypes };
export type { ComponentConfig, ComponentProtocol, LegacyComponentConfig };
